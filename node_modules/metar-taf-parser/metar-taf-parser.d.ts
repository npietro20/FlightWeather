declare enum MetarType {
    METAR = "METAR",
    SPECI = "SPECI"
}
declare enum CloudQuantity {
    /**
     * Sky clear
     */
    SKC = "SKC",
    /**
     * Few
     */
    FEW = "FEW",
    /**
     * Broken
     */
    BKN = "BKN",
    /**
     * Scattered
     */
    SCT = "SCT",
    /**
     * Overcast
     */
    OVC = "OVC",
    /**
     * No significant cloud
     */
    NSC = "NSC"
}
declare enum CloudType {
    /**
     * Cumulonimbus
     */
    CB = "CB",
    /**
     * Towering cumulus, cumulus congestus
     */
    TCU = "TCU",
    /**
     * Cirrus
     */
    CI = "CI",
    /**
     * Cirrocumulus
     */
    CC = "CC",
    /**
     * Cirrostratus
     */
    CS = "CS",
    /**
     * Altocumulus
     */
    AC = "AC",
    /**
     * Stratus
     */
    ST = "ST",
    /**
     * Cumulus
     */
    CU = "CU",
    /**
     * Astrostratus
     */
    AS = "AS",
    /**
     * Nimbostratus
     */
    NS = "NS",
    /**
     * Stratocumulus
     */
    SC = "SC"
}
/**
 * Moderate has no qualifier.
 */
declare enum Intensity {
    LIGHT = "-",
    /**
     * Heavy or well-developed
     */
    HEAVY = "+",
    IN_VICINITY = "VC"
}
declare enum Descriptive {
    SHOWERS = "SH",
    SHALLOW = "MI",
    PATCHES = "BC",
    PARTIAL = "PR",
    DRIFTING = "DR",
    THUNDERSTORM = "TS",
    BLOWING = "BL",
    FREEZING = "FZ"
}
declare enum Phenomenon {
    RAIN = "RA",
    DRIZZLE = "DZ",
    SNOW = "SN",
    SNOW_GRAINS = "SG",
    ICE_PELLETS = "PL",
    ICE_CRYSTALS = "IC",
    HAIL = "GR",
    SMALL_HAIL = "GS",
    UNKNOW_PRECIPITATION = "UP",
    FOG = "FG",
    VOLCANIC_ASH = "VA",
    MIST = "BR",
    HAZE = "HZ",
    WIDESPREAD_DUST = "DU",
    SMOKE = "FU",
    SAND = "SA",
    SPRAY = "PY",
    SQUALL = "SQ",
    SAND_WHIRLS = "PO",
    THUNDERSTORM = "TS",
    DUSTSTORM = "DS",
    SANDSTORM = "SS",
    FUNNEL_CLOUD = "FC",
    NO_SIGNIFICANT_WEATHER = "NSW"
}
declare enum TimeIndicator {
    AT = "AT",
    FM = "FM",
    TL = "TL"
}
/**
 * https://www.aviationweather.gov/taf/decoder
 */
declare enum WeatherChangeType {
    /**
     * FROM Group
     *
     * ie. `FM1600`
     *
     * The FM group is used when a rapid change, usually occuring in less than one
     * hour, in prevailing conditions is expected. Typically, a rapid change of
     * prevailing conditions to more or less a completely new set of prevailing
     * conditions is associated with a synoptic feature passing through the
     * terminal area (cold or warm frontal passage). Appended to the FM indicator
     * is the four-digit hour and minute the change is expected to begin and
     * continues until the next change group or until the end of the current
     * forecast.
     *
     * A FM group will mark the beginning of a new line in a TAF report. Each FM
     * group contains all the required elements -- wind, visibility, weather, and
     * sky condition. Weather will be omitted in FM groups when it is not
     * significant to aviation. FM groups will not include the contraction NSW.
     *
     * Examples:
     *
     *  1. `FM0100 SKC` - After 0100Z sky clear
     *  2. `FM1430 OVC020` - After 1430Z ceiling two thousand overcast
     */
    FM = "FM",
    /**
     * BECOMING Group
     *
     * ie. `BECMG 2224`
     *
     * The BECMG group is used when a gradual change in conditions is expected
     * over a longer time period, usually two hours. The time period when the
     * change is expected is a four-digit group with the beginning hour and ending
     * hour of the change period which follows the BECMG indicator. The gradual
     * change will occur at an unspecified time within this time period. Only the
     * conditions are carried over from the previous time group.
     *
     * Example:
     *
     *  1. `OVC012 BECMG 1416 BKN020` - Ceiling one thousand two hundred overcast.
     *     Then a gradual change to ceiling two thousand broken between 1400Z and
     *     1600Z.
     */
    BECMG = "BECMG",
    /**
     * TEMPORARY Group
     *
     * ie. `TEMPO 1316`
     *
     * The TEMPO group is used for any conditions in wind, visibility, weather, or
     * sky condition which are expected to last for generally less than an hour at
     * a time (occasional), and are expected to occur during less than half the
     * time period. The TEMPO indicator is followed by a four-digit group giving
     * the beginning hour and ending hour of the time period during which the
     * temporary conditions are expected. Only the changing forecast
     * meteorological conditions are included in TEMPO groups. The omitted
     * conditions are carried over from the previous time group.
     *
     * Examples:
     *
     *  1. `SCT030 TEMPO 1923 BKN030` - Three thousand scattered with occasional
     *     ceilings three thousand broken between 1900Z and 2300Z.
     *  2. `4SM HZ TEMPO 0006 2SM BR HZ` - Visibility four in haze with occasional
     *     visibility two in mist and haze between 0000Z and 0600Z.
     */
    TEMPO = "TEMPO",
    /**
     * For periods up to 30 minutes (`INTER` or intermittent).
     *
     * Otherwise, similar to `TEMPO`
     */
    INTER = "INTER",
    /**
     * Probability Forecast
     *
     * ie. `PROB40 0006`
     *
     * The probability or chance of thunderstorms or other precipitation events
     * occuring, along with associated weather conditions (wind, visibility, and
     * sky conditions).
     *
     * The PROB40 group is used when the occurrence of thunderstorms or
     * precipitation is in the 30% to less than 50% range, thus the probability
     * value 40 is appended to the PROB contraction. This is followed by a
     * four-digit group giving the beginning hour and ending hour of the time
     * period during which the thunderstorms or precipitation is expected.
     *
     * Note: PROB40 will not be shown during the first six hours of a forecast.
     *
     * Examples:
     *
     *  1. `PROB40 2102 1/2SM +TSRA` - Chance between 2100Z and 0200Z of
     *     visibility one-half thunderstorm, heavy rain.
     *  2. `PROB40 1014 1SM RASN` - Chance between 1000Z and 1400Z of visibility
     *     one rain and snow.
     *  3. `PROB40 2024 2SM FZRA` - Chance between 2000Z and 0000Z of visibility
     *     two freezing rain.
  
     */
    PROB = "PROB"
}
declare enum Direction {
    E = "E",
    ENE = "ENE",
    ESE = "ESE",
    N = "N",
    NE = "NE",
    NNE = "NNE",
    NNW = "NNW",
    NW = "NW",
    S = "S",
    SE = "SE",
    SSE = "SSE",
    SSW = "SSW",
    SW = "SW",
    W = "W",
    WNW = "WNW",
    WSW = "WSW"
}
declare enum DistanceUnit {
    Meters = "m",
    StatuteMiles = "SM"
}
declare enum SpeedUnit {
    Knot = "KT",
    MetersPerSecond = "MPS",
    KilometersPerHour = "KM/H"
}
/**
 * Used to indicate the actual value is greater than or less than the value written
 *
 * For example,
 *
 *  1. `P6SM` = visibility greater than 6 statute miles
 *  2. `M1/4SM` = visibility less than 1/4 statute mile
 */
declare enum ValueIndicator {
    GreaterThan = "P",
    LessThan = "M"
}
declare enum RunwayInfoTrend {
    Uprising = "U",
    Decreasing = "D",
    NoSignificantChange = "N"
}
declare enum RunwayInfoUnit {
    Feet = "FT",
    Meters = "m"
}
declare enum IcingIntensity {
    /**
     * Trace Icing or None.
     *
     * Air Force code 0 means a trace of icing.
     * World Meteorological Organization code 0 means no icing
     */
    None = "0",
    /** Light Mixed Icing. */
    Light = "1",
    /** Light Rime Icing In Cloud. */
    LightRimeIcingCloud = "2",
    /** Light Clear Icing In Precipitation. */
    LightClearIcingPrecipitation = "3",
    /** Moderate Mixed Icing. */
    ModerateMixedIcing = "4",
    /** Moderate Rime Icing In Cloud. */
    ModerateRimeIcingCloud = "5",
    /** Moderate Clear Icing In Precipitation. */
    ModerateClearIcingPrecipitation = "6",
    /** Severe Mixed Icing. */
    SevereMixedIcing = "7",
    /** Severe Rime Icing In Cloud. */
    SevereRimeIcingCloud = "8",
    /** Severe Clear Icing In Precipitation. */
    SevereClearIcingPrecipitation = "9"
}
declare enum TurbulenceIntensity {
    /** None. */
    None = "0",
    /** Light turbulence. */
    Light = "1",
    /** Moderate turbulence in clear air, occasional. */
    ModerateClearAirOccasional = "2",
    /** Moderate turbulence in clear air, frequent. */
    ModerateClearAirFrequent = "3",
    /** Moderate turbulence in cloud, occasional. */
    ModerateCloudOccasional = "4",
    /** Moderate turbulence in cloud, frequent. */
    ModerateCloudFrequent = "5",
    /** Severe turbulence in clear air, occasional. */
    SevereClearAirOccasional = "6",
    /** Severe turbulence in clear air, frequent. */
    SevereClearAirFrequent = "7",
    /** Severe turbulence in cloud, occasional. */
    SevereCloudOccasional = "8",
    /** Severe turbulence in cloud, frequent. */
    SevereCloudFrequent = "9",
    /** Extreme turbulence */
    Extreme = "X"
}
declare enum DepositType {
    /** (runway clearance in progress) */
    NotReported = "/",
    ClearDry = "0",
    Damp = "1",
    WetWaterPatches = "2",
    RimeFrostCovered = "3",
    DrySnow = "4",
    WetSnow = "5",
    Slush = "6",
    Ice = "7",
    CompactedSnow = "8",
    FrozenRidges = "9"
}
declare enum DepositCoverage {
    /**
     * Only reported by certain countries (e.g. Russia)
     */
    None = "0",
    /**
     * Not reported (e.g. due to rwy clearance in progress)
     */
    NotReported = "/",
    Less10 = "1",
    From11To25 = "2",
    From26To50 = "5",
    From51To100 = "9"
}
declare enum AltimeterUnit {
    /**
     * Inches of mercury (inHg)
     *
     * e.g. A2994 parses as 29.94 inHg
     */
    InHg = "inHg",
    /**
     * Hectopascals (hPa), also known as millibars
     *
     * e.g. Q1018 parses as 1018 millibars
     */
    HPa = "hPa"
}

declare const _default: {
    CloudQuantity: {
        BKN: string;
        FEW: string;
        NSC: string;
        OVC: string;
        SCT: string;
        SKC: string;
    };
    CloudType: {
        AC: string;
        AS: string;
        CB: string;
        CC: string;
        CI: string;
        CS: string;
        CU: string;
        NS: string;
        SC: string;
        ST: string;
        TCU: string;
    };
    Converter: {
        D: string;
        E: string;
        ENE: string;
        ESE: string;
        N: string;
        NE: string;
        NNE: string;
        NNW: string;
        NSC: string;
        NW: string;
        S: string;
        SE: string;
        SSE: string;
        SSW: string;
        SW: string;
        U: string;
        VRB: string;
        W: string;
        WNW: string;
        WSW: string;
    };
    DepositBrakingCapacity: {
        GOOD: string;
        MEDIUM: string;
        MEDIUM_GOOD: string;
        MEDIUM_POOR: string;
        NOT_REPORTED: string;
        POOR: string;
        UNRELIABLE: string;
    };
    DepositCoverage: {
        FROM_11_TO_25: string;
        FROM_26_TO_50: string;
        FROM_51_TO_100: string;
        LESS_10: string;
        NOT_REPORTED: string;
    };
    DepositThickness: {
        CLOSED: string;
        LESS_1_MM: string;
        NOT_REPORTED: string;
        THICKNESS_10: string;
        THICKNESS_15: string;
        THICKNESS_20: string;
        THICKNESS_25: string;
        THICKNESS_30: string;
        THICKNESS_35: string;
        THICKNESS_40: string;
    };
    DepositType: {
        CLEAR_DRY: string;
        COMPACTED_SNOW: string;
        DAMP: string;
        DRY_SNOW: string;
        FROZEN_RIDGES: string;
        ICE: string;
        NOT_REPORTED: string;
        RIME_FROST_COVERED: string;
        SLUSH: string;
        WET_SNOW: string;
        WET_WATER_PATCHES: string;
    };
    Descriptive: {
        BC: string;
        BL: string;
        DR: string;
        FZ: string;
        MI: string;
        PR: string;
        SH: string;
        TS: string;
    };
    Error: {
        prefix: string;
    };
    ErrorCode: {
        AirportNotFound: string;
        InvalidMessage: string;
    };
    Indicator: {
        M: string;
        P: string;
    };
    "intensity-plus": string;
    Intensity: {
        "-": string;
        VC: string;
    };
    MetarFacade: {
        InvalidIcao: string;
    };
    Phenomenon: {
        BR: string;
        DS: string;
        DU: string;
        DZ: string;
        FC: string;
        FG: string;
        FU: string;
        GR: string;
        GS: string;
        HZ: string;
        IC: string;
        PL: string;
        PO: string;
        PY: string;
        RA: string;
        SA: string;
        SG: string;
        SN: string;
        SQ: string;
        SS: string;
        TS: string;
        UP: string;
        VA: string;
        NSW: string;
    };
    Remark: {
        ALQDS: string;
        AO1: string;
        AO2: string;
        AO2A: string;
        BASED: string;
        Barometer: string[];
        Ceiling: {
            Height: string;
            Second: {
                Location: string;
            };
        };
        DSNT: string;
        FCST: string;
        FUNNELCLOUD: string;
        HVY: string;
        Hail: {
            "0": string;
            LesserThan: string;
        };
        Hourly: {
            Maximum: {
                Minimum: {
                    Temperature: string;
                };
                Temperature: string;
            };
            Minimum: {
                Temperature: string;
            };
            Temperature: {
                "0": string;
                Dew: {
                    Point: string;
                };
            };
        };
        Ice: {
            Accretion: {
                Amount: string;
            };
        };
        LGT: string;
        LTG: string;
        MOD: string;
        Next: {
            Forecast: {
                By: string;
            };
        };
        NXT: string;
        ON: string;
        Obscuration: string;
        PRESFR: string;
        PRESRR: string;
        PeakWind: string;
        Precipitation: {
            Amount: {
                "24": string;
                "3": {
                    "6": string;
                };
                Hourly: string;
            };
            Beg: {
                "0": string;
                End: string;
            };
            End: string;
        };
        Pressure: {
            Tendency: string;
        };
        SLPNO: string;
        Sea: {
            Level: {
                Pressure: string;
            };
        };
        Second: {
            Location: {
                Visibility: string;
            };
        };
        Sector: {
            Visibility: string;
        };
        Snow: {
            Depth: string;
            Increasing: {
                Rapidly: string;
            };
            Pellets: string;
        };
        Sunshine: {
            Duration: string;
        };
        Surface: {
            Visibility: string;
        };
        TORNADO: string;
        Thunderstorm: {
            Location: {
                "0": string;
                Moving: string;
            };
        };
        Tornadic: {
            Activity: {
                BegEnd: string;
                Beginning: string;
                Ending: string;
            };
        };
        Tower: {
            Visibility: string;
        };
        VIRGA: string;
        Variable: {
            Prevailing: {
                Visibility: string;
            };
            Sky: {
                Condition: {
                    "0": string;
                    Height: string;
                };
            };
        };
        Virga: {
            Direction: string;
        };
        WATERSPOUT: string;
        Water: {
            Equivalent: {
                Snow: {
                    Ground: string;
                };
            };
        };
        WindShift: {
            "0": string;
            FROPA: string;
        };
    };
    TimeIndicator: {
        AT: string;
        FM: string;
        TL: string;
    };
    ToString: {
        airport: string;
        altimeter: string;
        amendment: string;
        auto: string;
        cavok: string;
        clouds: string;
        day: {
            hour: string;
            month: string;
        };
        deposit: {
            braking: string;
            coverage: string;
            thickness: string;
            type: string;
        };
        descriptive: string;
        dew: {
            point: string;
        };
        end: {
            day: {
                month: string;
            };
            hour: {
                day: string;
            };
        };
        height: {
            feet: string;
            meter: string;
        };
        indicator: string;
        intensity: string;
        message: string;
        name: string;
        nosig: string;
        phenomenons: string;
        probability: string;
        quantity: string;
        remark: string;
        report: {
            time: string;
        };
        runway: {
            info: string;
        };
        start: {
            day: {
                month: string;
            };
            hour: {
                day: string;
            };
            minute: string;
        };
        temperature: {
            "0": string;
            max: string;
            min: string;
        };
        trend: string;
        trends: string;
        type: string;
        vertical: {
            visibility: string;
        };
        visibility: {
            main: string;
            max: string;
            min: {
                "0": string;
                direction: string;
            };
        };
        weather: {
            conditions: string;
        };
        wind: {
            direction: {
                "0": string;
                degrees: string;
            };
            gusts: string;
            max: {
                variation: string;
            };
            min: {
                variation: string;
            };
            speed: string;
            unit: string;
        };
    };
    WeatherChangeType: {
        BECMG: string;
        FM: string;
        PROB: string;
        TEMPO: string;
    };
};

type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
type Locale = DeepPartial<typeof _default>;

interface ICeilingHeightRemark extends IBaseRemark {
    type: RemarkType.CeilingHeight;
    /**
     * Ceiling min height (varying between min and max) above ground level
     */
    min: number;
    /**
     * Ceiling max height (varying between min and max) above ground level
     */
    max: number;
}

interface ICeilingSecondLocationRemark extends IBaseRemark {
    type: RemarkType.CeilingSecondLocation;
    height: number;
    location: string;
}

interface IHailSizeRemark extends IBaseRemark {
    type: RemarkType.HailSize;
    size: number;
}

interface IHourlyMaximumMinimumTemperatureRemark extends IBaseRemark {
    type: RemarkType.HourlyMaximumMinimumTemperature;
    /**
     * Maximum temperature in C
     */
    max: number;
    /**
     * Minimum temperature in C
     */
    min: number;
}

interface IHourlyMaximumTemperatureRemark extends IBaseRemark {
    type: RemarkType.HourlyMaximumTemperature;
    /**
     * Maximum temperature in C
     */
    max: number;
}

interface IHourlyMinimumTemperatureRemark extends IBaseRemark {
    type: RemarkType.HourlyMinimumTemperature;
    /**
     * Minimum temperature in C
     */
    min: number;
}

interface IHourlyPrecipitationAmountRemark extends IBaseRemark {
    type: RemarkType.HourlyPrecipitationAmount;
    /**
     * In inches
     */
    amount: number;
}

interface IHourlyPressureRemark extends IBaseRemark {
    type: RemarkType.HourlyPressure;
    /**
     * https://www.e-education.psu.edu/files/meteo101/image/Section13/metar_decoding1203.html
     *
     * | Code Figure |                                     Description                                    |                        Primary Requirement                        |
     * |:-----------:|:----------------------------------------------------------------------------------:|:-----------------------------------------------------------------:|
     * |      0      | Increasing, then decreasing.                                                       | Atmospheric pressure now higher than 3 hours ago. (x3 rows below) |
     * |      1      | Increasing, then steady, or increasing then increasing more slowly.                |                                                                   |
     * |      2      | Increasing steadily or unsteadily.                                                 |                                                                   |
     * |      3      | Decreasing or steady, then increasing; or increasing then increasing more rapidly. |                                                                   |
     * |      0      | Increasing, then decreasing.                                                       | Atmospheric pressure now same as 3 hours ago. (x3 rows below)     |
     * |      4      | Steady                                                                             |                                                                   |
     * |      5      | Decreasing then increasing.                                                        |                                                                   |
     * |      5      | Decreasing, then increasing.                                                       | Atmospheric pressure now lower than 3 hours ago. (x3 rows below)  |
     * |      6      | Decreasing, then steady, or decreasing then decreasing more slowly.                |                                                                   |
     * |      7      | Decreasing steadily or unsteadily.                                                 |                                                                   |
     * |      8      | Steady or increasing, then decreasing; or decreasing then decreasing more rapidly. |                                                                   |
     */
    code: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
    /**
     * In hectopascals
     */
    pressureChange: number;
}

interface IHourlyTemperatureDewPointRemark extends IBaseRemark {
    type: RemarkType.HourlyTemperatureDewPoint;
    /**
     * In C
     */
    temperature: number;
    /**
     * In C
     */
    dewPoint?: number;
}

interface IIceAccretionRemark extends IBaseRemark {
    type: RemarkType.IceAccretion;
    /**
     * In inches
     */
    amount: number;
    periodInHours: number;
}

interface IObscurationRemark extends IBaseRemark {
    type: RemarkType.Obscuration;
    quantity: CloudQuantity;
    height: number;
    phenomenon: Phenomenon;
}

interface IPrecipitationAmount24HourRemark extends IBaseRemark {
    type: RemarkType.PrecipitationAmount24Hour;
    /**
     * In inches
     */
    amount: number;
}

interface IPrecipitationAmount36HourRemark extends IBaseRemark {
    type: RemarkType.PrecipitationAmount36Hour;
    periodInHours: 3 | 6;
    /**
     * In inches
     */
    amount: number;
}

interface IPrecipitationBegEndRemark extends IBaseRemark {
    type: RemarkType.PrecipitationBegEnd;
    descriptive?: Descriptive;
    phenomenon: Phenomenon;
    startHour?: number;
    startMin: number;
    endHour?: number;
    endMin: number;
}

interface IPrevailingVisibilityRemark extends IBaseRemark {
    type: RemarkType.PrevailingVisibility;
    minVisibility: number;
    maxVisibility: number;
}

interface ISeaLevelPressureRemark extends IBaseRemark {
    type: RemarkType.SeaLevelPressure;
    /**
     * Sea level pressure, in hPa/millibars
     */
    pressure: number;
}

interface ISecondLocationVisibilityRemark extends IBaseRemark {
    type: RemarkType.SecondLocationVisibility;
    distance: number;
    location: string;
}

interface ISectorVisibilityRemark extends IBaseRemark {
    type: RemarkType.SectorVisibility;
    direction: Direction;
    distance: number;
}

interface ISmallHailSizeRemark extends IBaseRemark {
    type: RemarkType.SmallHailSize;
    size: number;
}

interface ISnowDepthRemark extends IBaseRemark {
    type: RemarkType.SnowDepth;
    depth: number;
}

interface ISnowIncreaseRemark extends IBaseRemark {
    type: RemarkType.SnowIncrease;
    inchesLastHour: number;
    totalDepth: number;
}

interface ISnowPelletsRemark extends IBaseRemark {
    type: RemarkType.SnowPellets;
    amount: "LGT" | "MOD" | "HVY";
}

interface ISunshineDurationRemark extends IBaseRemark {
    type: RemarkType.SunshineDuration;
    duration: number;
}

interface ISurfaceVisibilityRemark extends IBaseRemark {
    type: RemarkType.SurfaceVisibility;
    distance: number;
}

interface IThunderStormLocationRemark extends IBaseRemark {
    type: RemarkType.ThunderStormLocation;
    location: Direction;
}

interface IThunderStormLocationMovingRemark extends IBaseRemark {
    type: RemarkType.ThunderStormLocationMoving;
    /**
     * Current location is relative of the station
     */
    location: Direction;
    /**
     * Direction moving (eg. "SW")
     */
    moving: Direction;
}

interface ITornadicActivityBegRemark extends IBaseRemark {
    type: RemarkType.TornadicActivityBeg;
    tornadicType: "TORNADO" | "FUNNEL CLOUD" | "WATERSPOUT";
    startHour?: number;
    startMinute: number;
    distance: number;
    direction: Direction;
}

interface ITornadicActivityBegEndRemark extends IBaseRemark {
    type: RemarkType.TornadicActivityBegEnd;
    tornadicType: "TORNADO" | "FUNNEL CLOUD" | "WATERSPOUT";
    startHour?: number;
    startMinute: number;
    endHour?: number;
    endMinute: number;
    distance: number;
    direction: Direction;
}

interface ITornadicActivityEndRemark extends IBaseRemark {
    type: RemarkType.TornadicActivityEnd;
    tornadicType: "TORNADO" | "FUNNEL CLOUD" | "WATERSPOUT";
    endHour?: number;
    endMinute: number;
    distance: number;
    direction: Direction;
}

interface ITowerVisibilityRemark extends IBaseRemark {
    type: RemarkType.TowerVisibility;
    distance: number;
}

interface IVariableSkyRemark extends IBaseRemark {
    type: RemarkType.VariableSky;
    cloudQuantityRange: [CloudQuantity, CloudQuantity];
}

interface IVariableSkyHeightRemark extends IBaseRemark {
    type: RemarkType.VariableSkyHeight;
    height: number;
    cloudQuantityRange: [CloudQuantity, CloudQuantity];
}

interface IVirgaDirectionRemark extends IBaseRemark {
    type: RemarkType.VirgaDirection;
    direction: Direction;
}

interface IWaterEquivalentSnowRemark extends IBaseRemark {
    type: RemarkType.WaterEquivalentSnow;
    amount: number;
}

interface IWindPeakCommandRemark extends IBaseRemark {
    type: RemarkType.WindPeak;
    /**
     * In knots
     */
    speed: number;
    degrees: number;
    startHour?: number;
    startMinute: number;
}

interface IWindShiftRemark extends IBaseRemark {
    type: RemarkType.WindShift;
    startHour?: number;
    startMinute: number;
}

interface IWindShiftFropaRemark extends IBaseRemark {
    type: RemarkType.WindShiftFropa;
    startHour?: number;
    startMinute: number;
}

type DefaultRemarkTypes = RemarkType.AO1 | RemarkType.AO2 | RemarkType.PRESFR | RemarkType.PRESRR | RemarkType.TORNADO | RemarkType.FUNNELCLOUD | RemarkType.WATERSPOUT | RemarkType.VIRGA;
interface IDefaultCommandRemark extends IBaseRemark {
    type: DefaultRemarkTypes;
}

interface IPrecipitationBegRemark extends IBaseRemark {
    type: RemarkType.PrecipitationBeg;
    descriptive?: Descriptive;
    phenomenon: Phenomenon;
    startHour?: number;
    startMin: number;
}

interface IPrecipitationEndRemark extends IBaseRemark {
    type: RemarkType.PrecipitationEnd;
    descriptive?: Descriptive;
    phenomenon: Phenomenon;
    endHour?: number;
    endMin: number;
}

interface INextForecastByRemark extends IBaseRemark {
    type: RemarkType.NextForecastBy;
    day: number;
    hour: number;
    minute: number;
}
interface INextForecastByRemarkDated extends INextForecastByRemark {
    type: RemarkType.NextForecastBy;
    date: Date;
}

interface IBaseRemark {
    type: RemarkType;
    description?: string;
    raw: string;
}
interface IUnknownRemark extends IBaseRemark {
    type: RemarkType.Unknown;
}
declare enum RemarkType {
    Unknown = "Unknown",
    AO1 = "AO1",
    AO2 = "AO2",
    PRESFR = "PRESFR",
    PRESRR = "PRESRR",
    TORNADO = "TORNADO",
    FUNNELCLOUD = "FUNNELCLOUD",
    WATERSPOUT = "WATERSPOUT",
    VIRGA = "VIRGA",
    WindPeak = "WindPeak",
    WindShiftFropa = "WindShiftFropa",
    WindShift = "WindShift",
    TowerVisibility = "TowerVisibility",
    SurfaceVisibility = "SurfaceVisibility",
    PrevailingVisibility = "PrevailingVisibility",
    SecondLocationVisibility = "SecondLocationVisibility",
    SectorVisibility = "SectorVisibility",
    TornadicActivityBegEnd = "TornadicActivityBegEnd",
    TornadicActivityBeg = "TornadicActivityBeg",
    TornadicActivityEnd = "TornadicActivityEnd",
    PrecipitationBeg = "PrecipitationBeg",
    PrecipitationBegEnd = "PrecipitationBegEnd",
    PrecipitationEnd = "PrecipitationEnd",
    ThunderStormLocationMoving = "ThunderStormLocationMoving",
    ThunderStormLocation = "ThunderStormLocation",
    SmallHailSize = "SmallHailSize",
    HailSize = "HailSize",
    SnowPellets = "SnowPellets",
    VirgaDirection = "VirgaDirection",
    CeilingHeight = "CeilingHeight",
    Obscuration = "Obscuration",
    VariableSkyHeight = "VariableSkyHeight",
    VariableSky = "VariableSky",
    CeilingSecondLocation = "CeilingSecondLocation",
    SeaLevelPressure = "SeaLevelPressure",
    SnowIncrease = "SnowIncrease",
    HourlyMaximumMinimumTemperature = "HourlyMaximumMinimumTemperature",
    HourlyMaximumTemperature = "HourlyMaximumTemperature",
    HourlyMinimumTemperature = "HourlyMinimumTemperature",
    HourlyPrecipitationAmount = "HourlyPrecipitationAmount",
    HourlyTemperatureDewPoint = "HourlyTemperatureDewPoint",
    HourlyPressure = "HourlyPressure",
    IceAccretion = "IceAccretion",
    PrecipitationAmount36Hour = "PrecipitationAmount36Hour",
    PrecipitationAmount24Hour = "PrecipitationAmount24Hour",
    SnowDepth = "SnowDepth",
    SunshineDuration = "SunshineDuration",
    WaterEquivalentSnow = "WaterEquivalentSnow",
    NextForecastBy = "NextForecastBy"
}
type RemarkBase = IUnknownRemark | IDefaultCommandRemark | ICeilingHeightRemark | ICeilingSecondLocationRemark | IHailSizeRemark | IHourlyMaximumMinimumTemperatureRemark | IHourlyMaximumTemperatureRemark | IHourlyMinimumTemperatureRemark | IHourlyPrecipitationAmountRemark | IHourlyPressureRemark | IHourlyTemperatureDewPointRemark | IIceAccretionRemark | IObscurationRemark | IPrecipitationAmount24HourRemark | IPrecipitationAmount36HourRemark | IPrecipitationBegRemark | IPrecipitationBegEndRemark | IPrecipitationEndRemark | IPrevailingVisibilityRemark | ISeaLevelPressureRemark | ISecondLocationVisibilityRemark | ISectorVisibilityRemark | ISmallHailSizeRemark | ISnowDepthRemark | ISnowIncreaseRemark | ISnowPelletsRemark | ISunshineDurationRemark | ISurfaceVisibilityRemark | IThunderStormLocationRemark | IThunderStormLocationMovingRemark | ITornadicActivityBegRemark | ITornadicActivityBegEndRemark | ITornadicActivityEndRemark | ITowerVisibilityRemark | IVariableSkyRemark | IVariableSkyHeightRemark | IVirgaDirectionRemark | IWaterEquivalentSnowRemark | IWindPeakCommandRemark | IWindShiftRemark | IWindShiftFropaRemark;
type RemarkDated = RemarkBase | INextForecastByRemarkDated;
type Remark = RemarkBase | INextForecastByRemark;

interface IWind {
    speed: number;
    direction: string;
    /**
     * If undefined, direction is variable
     */
    degrees?: number;
    gust?: number;
    minVariation?: number;
    maxVariation?: number;
    unit: SpeedUnit;
}
interface IWindShear extends IWind {
    height: number;
}
interface Distance {
    indicator?: ValueIndicator;
    value: number;
    unit: DistanceUnit;
    /** No Directional Visibility */
    ndv?: true;
}
type Visibility = Distance & {
    /**
     * Never in North American METARs
     */
    min?: {
        /** Always in meters */
        value: number;
        direction: string;
    };
};
interface IWeatherCondition {
    intensity?: Intensity;
    descriptive?: Descriptive;
    phenomenons: Phenomenon[];
}
declare function isWeatherConditionValid(weather: IWeatherCondition): boolean;
interface IAltimeter {
    value: number;
    unit: AltimeterUnit;
}
interface ITemperature {
    temperature: number;
    day: number;
    hour: number;
}
interface ITemperatureDated extends ITemperature {
    date: Date;
}
type RunwayInfo = IRunwayInfoRange | IRunwayInfoDeposit;
interface IBaseRunwayInfo {
    name: string;
}
interface IRunwayInfoRange extends IBaseRunwayInfo {
    name: string;
    minRange: number;
    maxRange?: number;
    /**
     * Only used in North American runway ranges (feet unit of measurement)
     */
    indicator?: ValueIndicator;
    /**
     * Only used in IACO runway ranges (meters unit of measurement)
     */
    trend?: RunwayInfoTrend;
    unit: RunwayInfoUnit;
}
interface IRunwayInfoDeposit extends IBaseRunwayInfo {
    depositType?: DepositType;
    coverage?: DepositCoverage;
    /**
     * Depth of deposit
     *
     * Note: the quoted depth is the mean of a number of reading or if operationally significant the greatest depth measured.
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `"00"` | Less than 1mm |
     * | `"01"` to `"90"` | Measurement in mm |
     * | `"92"` | 10cm |
     * | `"93"` | 15cm |
     * | `"94"` | 20cm |
     * | `"95"` | 25cm |
     * | `"96"` | 30cm |
     * | `"97"` | 35cm |
     * | `"98"` | 40cm or more |
     * | `"99"` | Runway not operational due to snow, slush, ice, large drifts or runway clearance, depth not reported |
     * | `"//"` | Not operationally significant or not measurable |
     */
    thickness?: string;
    /**
     * Friction Coefficient or Braking Action
     *
     * Note: Where braking action is assessed at a number of points along the runway the mean value will be transmitted or if operationally significant the lowest value.
     *
     * If measuring equipment does not allow measurement of friction with satisfactory reliability (such as contaminated by wet snow, slush or loose snow) the figure 99 will be used.
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `"28"` | Friction coefficient 0.28
     * | `"35"` | Friction coefficient 0.35
     * | `"91"` | Braking action poor
     * | `"92"` | Braking action medium to poor
     * | `"93"` | Braking action medium
     * | `"94"` | Braking action medium to good
     * | `"95"` | Braking action good
     * | `"99"` | Figures unreliable
     * | `"//"` | Braking action not reported or runway not operations or airport closed.
     */
    brakingCapacity?: string;
}
interface ICloud {
    height?: number;
    quantity: CloudQuantity;
    type?: CloudType;
    /**
     * Very uncommon. For example "FEW025TCU/CB" seen at airport VOTR.
     *
     * This property can be ignored in almost all cases.
     */
    secondaryType?: CloudType;
}
interface IFlags {
    /**
     * Amended TAF
     */
    amendment?: true;
    /**
     * Amended METAR
     */
    auto?: true;
    /**
     * Canceled TAF
     */
    canceled?: true;
    /**
     * Corrected METAR/TAF
     */
    corrected?: true;
    /**
     * No data
     */
    nil?: true;
}
interface IAbstractWeatherContainer extends IFlags {
    wind?: IWind;
    visibility?: Visibility;
    verticalVisibility?: number;
    windShear?: IWindShear;
    cavok?: true;
    remark?: string;
    remarks: Remark[];
    clouds: ICloud[];
    weatherConditions: IWeatherCondition[];
}
interface IAbstractValidity {
    startDay: number;
    startHour: number;
}
/**
 * Exclusive for the TS port (because python has `time()` and js does not)
 */
interface ITime {
    hour?: number;
    minute?: number;
}
interface IAbstractWeatherCode extends IAbstractWeatherContainer, ITime {
    day?: number;
    message: string;
    station: string;
    trends: IAbstractTrend[];
}
interface ITafGroups {
    turbulence?: ITurbulence[];
    icing?: IIcing[];
}
interface IAbstractWeatherCodeDated extends IAbstractWeatherCode {
    issued: Date;
}
interface IMetar extends IAbstractWeatherCode {
    type?: MetarType;
    temperature?: number;
    dewPoint?: number;
    altimeter?: IAltimeter;
    nosig?: true;
    runwaysInfo: RunwayInfo[];
    /**
     * Not used in North America
     */
    trends: IMetarTrend[];
}
interface ITAF extends IAbstractWeatherCode, ITafGroups {
    validity: IValidity;
    maxTemperature?: ITemperature;
    minTemperature?: ITemperature;
    trends: TAFTrend[];
    /**
     * Just the first part of the TAF message without trends (FM, BECMG, etc)
     */
    initialRaw: string;
}
interface IAbstractTrend extends IAbstractWeatherContainer {
    type: WeatherChangeType;
    raw: string;
}
interface IMetarTrendTime extends ITime {
    type: TimeIndicator;
}
interface IMetarTrend extends IAbstractTrend {
    times: IMetarTrendTime[];
}
interface IBaseTAFTrend extends IAbstractTrend, ITafGroups {
    /**
     * Will not be found on FM trends. May exist on others.
     *
     * If does not exist, probability is > 40%
     */
    probability?: number;
    /**
     * All trends have `startDay` and `startHour` defined. Additionally:
     *
     * - FM trends also have `startMinutes`. They **DO NOT** have an explicit end
     *   validity (it is implied by the following FM).
     * - All others (PROB, TEMPO, BECMG, INTER) have `endDay` and `endHour`.
     *
     * All properties are allowed to be accessed (as optionals), but if you want
     * type guarantees, you can check the trend type. For example:
     *
     * ```ts
     * switch (trend.type) {
     *   case WeatherChangeType.FM:
     *     // trend.validity now has startMinutes defined
     *     break;
     *   case WeatherChangeType.PROB:
     *   case WeatherChangeType.BECMG:
     *   case WeatherChangeType.TEMPO:
     *   case WeatherChangeType.INTER:
     *     // trend.validity now has endHour, endDay defined
     * }
     * ```
     */
    validity: IAbstractValidity & Partial<IFMValidity> & Partial<IValidity>;
}
type TAFTrend = IBaseTAFTrend & ({
    type: WeatherChangeType.FM;
    validity: IFMValidity;
} | {
    type: WeatherChangeType;
    validity: IValidity;
});
interface IEndValidity {
    endHour: number;
    endDay: number;
}
interface IValidity extends IAbstractValidity, IEndValidity {
}
interface IValidityDated extends IAbstractValidity, IEndValidity {
    start: Date;
    end: Date;
}
interface IFMValidity extends IAbstractValidity {
    startMinutes: number;
}
/**
 * Represents icing in a TAF.
 *
 * http://prnfc.org/wp-content/uploads/2016/12/AF-METAR-TAF-Codes.pdf#page=28
 *
 * Top of icing = `baseHeight` + `depth`
 */
interface IIcing {
    /** The intensity of the icing. */
    intensity: IcingIntensity;
    /** The base of the icing layer in feet. */
    baseHeight: number;
    /** The icing layer depth in feet. */
    depth: number;
}
/**
 * Represents turbulence in a TAF.
 *
 * http://prnfc.org/wp-content/uploads/2016/12/AF-METAR-TAF-Codes.pdf#page=29
 *
 * Top of icing = `baseHeight` + `depth`
 */
interface ITurbulence {
    /** The intensity of the turbulence. */
    intensity: TurbulenceIntensity;
    /** The base limit of the turbulence layer in feet. */
    baseHeight: number;
    /** The turbulence layer depth in feet. */
    depth: number;
}

interface IMetarDated extends IMetar {
    issued: Date;
}

type TAFTrendDated = IAbstractTrend & IBaseTAFTrend & {
    validity: IBaseTAFTrend["validity"] & {
        start: Date;
        end?: Date;
    };
    remarks: RemarkDated[];
} & ({
    type: WeatherChangeType.FM;
    validity: IFMValidity & {
        start: Date;
    };
} | {
    type: WeatherChangeType;
    validity: IValidity & {
        start: Date;
        end: Date;
    };
});
interface ITAFDated extends ITAF {
    issued: Date;
    validity: ITAF["validity"] & {
        start: Date;
        end: Date;
    };
    minTemperature?: ITemperatureDated;
    maxTemperature?: ITemperatureDated;
    trends: TAFTrendDated[];
    remarks: RemarkDated[];
}

declare abstract class ParseError extends Error {
    name: string;
    constructor(message?: string);
}
declare class InvalidWeatherStatementError extends ParseError {
    name: string;
    cause?: unknown;
    constructor(cause?: unknown);
}
/**
 * Thrown when an input contains data elements that are recognized but
 * intentionally not supported.
 */
declare class PartialWeatherStatementError extends InvalidWeatherStatementError {
    name: string;
    part: number;
    total: number;
    constructor(partialMessage: string, part: number, total: number);
}
/**
 * Thrown when command marked as canParse, but couldn't parse when
 * executing (for example, an invalid CloudQuantity)
 */
declare class CommandExecutionError extends ParseError {
    name: string;
    constructor(message: string);
}
/**
 * Should never occur
 */
declare class UnexpectedParseError extends ParseError {
    name: string;
    constructor(message?: string);
}

/**
 * The initial forecast, extracted from the first line of the TAF, does not have
 * a trend type (FM, BECMG, etc)
 */
type ForecastWithoutDates = Omit<TAFTrendDated, "type"> & Partial<Pick<TAFTrendDated, "type">>;
type ForecastWithoutValidity = Omit<ForecastWithoutDates, "validity">;
type Forecast = Omit<ForecastWithoutValidity, "type"> & {
    start: Date;
    end: Date;
} & ({
    type: Exclude<WeatherChangeType, WeatherChangeType.BECMG> | undefined;
} | {
    type: WeatherChangeType.BECMG;
    /**
     * BECMG has a special date, `by`, for when the transition will finish
     *
     * For example, a BECMG trend may `start` at 1:00PM and `end` at 5:00PM, but
     * `by` may be `3:00PM` to denote that conditions will transition from a period of
     * 1:00PM to 3:00PM
     */
    by: Date;
});
interface IForecastContainer extends IFlags {
    station: string;
    issued: Date;
    start: Date;
    end: Date;
    message: string;
    forecast: Forecast[];
    amendment?: true;
    maxTemperature?: ITemperatureDated;
    minTemperature?: ITemperatureDated;
}
interface ICompositeForecast {
    /**
     * Prevailing conditions: type is `FM`, `BECMG` or initial conditions (`undefined` type)
     */
    prevailing: Forecast;
    /**
     * supplemental forecasts may have probabilities of occuring, be temporary,
     * or otherwise notable change of conditions. They enhance the prevailing forecast.
     *
     * `type` is (`TEMPO`, `INTER` or `PROB`)
     */
    supplemental: Forecast[];
}
declare class TimestampOutOfBoundsError extends ParseError {
    name: string;
    constructor(message?: string);
}
declare function getCompositeForecastForDate(date: Date, forecastContainer: IForecastContainer): ICompositeForecast;

interface IMetarTAFParserOptions {
    locale?: Locale;
}
interface IMetarTAFParserOptionsDated extends IMetarTAFParserOptions {
    /**
     * This date should be the date the report was issued.
     *
     * This date is needed to create actual timestamps since the report only has
     * day of month, hour, and minute (and sometimes not even that).
     */
    issued: Date;
}
declare function parseMetar(rawMetar: string, options?: IMetarTAFParserOptions): IMetar;
declare function parseMetar(rawMetar: string, options?: IMetarTAFParserOptionsDated): IMetarDated;
declare function parseTAF(rawTAF: string, options?: IMetarTAFParserOptions): ITAF;
declare function parseTAF(rawTAF: string, options?: IMetarTAFParserOptionsDated): ITAFDated;
declare function parseTAFAsForecast(rawTAF: string, options: IMetarTAFParserOptionsDated): IForecastContainer;

export { AltimeterUnit, CloudQuantity, CloudType, CommandExecutionError, DepositCoverage, DepositType, Descriptive, Direction, type Distance, DistanceUnit, type Forecast, type IAbstractTrend, type IAbstractValidity, type IAbstractWeatherCode, type IAbstractWeatherCodeDated, type IAbstractWeatherContainer, type IAltimeter, type IBaseRemark, type IBaseRunwayInfo, type IBaseTAFTrend, type ICeilingHeightRemark, type ICeilingSecondLocationRemark, type ICloud, type ICompositeForecast, type IEndValidity, type IFMValidity, type IFlags, type IForecastContainer, type IHourlyMaximumMinimumTemperatureRemark, type IHourlyMaximumTemperatureRemark, type IHourlyMinimumTemperatureRemark, type IHourlyPrecipitationAmountRemark, type IHourlyPressureRemark, type IHourlyTemperatureDewPointRemark, type IIceAccretionRemark, type IIcing, type IMetar, type IMetarDated, type IMetarTAFParserOptions, type IMetarTAFParserOptionsDated, type IMetarTrend, type IMetarTrendTime, type INextForecastByRemark, type INextForecastByRemarkDated, type IObscurationRemark, type IPrecipitationAmount24HourRemark, type IPrecipitationAmount36HourRemark, type IPrecipitationBegEndRemark, type IPrevailingVisibilityRemark, type IRunwayInfoDeposit, type IRunwayInfoRange, type ISeaLevelPressureRemark, type ISecondLocationVisibilityRemark, type ISectorVisibilityRemark, type ISmallHailSizeRemark, type ISnowIncreaseRemark, type ISnowPelletsRemark, type ISunshineDurationRemark, type ISurfaceVisibilityRemark, type ITAF, type ITAFDated, type ITafGroups, type ITemperature, type ITemperatureDated, type IThunderStormLocationMovingRemark, type IThunderStormLocationRemark, type ITime, type ITornadicActivityBegEndRemark, type ITornadicActivityBegRemark, type ITornadicActivityEndRemark, type ITowerVisibilityRemark, type ITurbulence, type IUnknownRemark, type IValidity, type IValidityDated, type IVariableSkyHeightRemark, type IVariableSkyRemark, type IVirgaDirectionRemark, type IWaterEquivalentSnowRemark, type IWeatherCondition, type IWind, type IWindPeakCommandRemark, type IWindShear, type IWindShiftFropaRemark, IcingIntensity, Intensity, InvalidWeatherStatementError, type Locale, MetarType, ParseError, PartialWeatherStatementError, Phenomenon, type Remark, type RemarkDated, RemarkType, type RunwayInfo, RunwayInfoTrend, RunwayInfoUnit, SpeedUnit, type TAFTrend, type TAFTrendDated, TimeIndicator, TimestampOutOfBoundsError, TurbulenceIntensity, UnexpectedParseError, ValueIndicator, type Visibility, WeatherChangeType, getCompositeForecastForDate, isWeatherConditionValid, parseMetar, parseTAF, parseTAFAsForecast };
